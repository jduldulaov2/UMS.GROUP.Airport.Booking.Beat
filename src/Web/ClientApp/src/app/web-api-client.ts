//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAirportClient {
    getAllAirportByCountry(countryId: number | null | undefined): Observable<GetAllAirportByCountryQueryDto[]>;
    getAirportById(uniqueId: string | null | undefined): Observable<ResultOfGetAirportByIdQueryDto>;
    getAllAirport(): Observable<GetAllAirportQueryDto[]>;
    getAirportByName(airportName: string | null | undefined): Observable<GetAirportByNameQueryDto[]>;
    createAirport(command: CreateAirportCommand): Observable<ResultOfCreateAirportCommandDto>;
    updateAirport(command: UpdateAirportCommand): Observable<ResultOfUpdateAirportCommandDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AirportClient implements IAirportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllAirportByCountry(countryId: number | null | undefined): Observable<GetAllAirportByCountryQueryDto[]> {
        let url_ = this.baseUrl + "/api/Airport/GetAllAirportByCountry?";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAirportByCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAirportByCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllAirportByCountryQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllAirportByCountryQueryDto[]>;
        }));
    }

    protected processGetAllAirportByCountry(response: HttpResponseBase): Observable<GetAllAirportByCountryQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllAirportByCountryQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAirportById(uniqueId: string | null | undefined): Observable<ResultOfGetAirportByIdQueryDto> {
        let url_ = this.baseUrl + "/api/Airport/GetAirportById?";
        if (uniqueId !== undefined && uniqueId !== null)
            url_ += "UniqueId=" + encodeURIComponent("" + uniqueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAirportById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAirportById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetAirportByIdQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetAirportByIdQueryDto>;
        }));
    }

    protected processGetAirportById(response: HttpResponseBase): Observable<ResultOfGetAirportByIdQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetAirportByIdQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllAirport(): Observable<GetAllAirportQueryDto[]> {
        let url_ = this.baseUrl + "/api/Airport/GetAllAirport";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAirport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAirport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllAirportQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllAirportQueryDto[]>;
        }));
    }

    protected processGetAllAirport(response: HttpResponseBase): Observable<GetAllAirportQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllAirportQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAirportByName(airportName: string | null | undefined): Observable<GetAirportByNameQueryDto[]> {
        let url_ = this.baseUrl + "/api/Airport/GetAirportByName?";
        if (airportName !== undefined && airportName !== null)
            url_ += "AirportName=" + encodeURIComponent("" + airportName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAirportByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAirportByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAirportByNameQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAirportByNameQueryDto[]>;
        }));
    }

    protected processGetAirportByName(response: HttpResponseBase): Observable<GetAirportByNameQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAirportByNameQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createAirport(command: CreateAirportCommand): Observable<ResultOfCreateAirportCommandDto> {
        let url_ = this.baseUrl + "/api/Airport/CreateAirport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAirport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAirport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateAirportCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateAirportCommandDto>;
        }));
    }

    protected processCreateAirport(response: HttpResponseBase): Observable<ResultOfCreateAirportCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateAirportCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAirport(command: UpdateAirportCommand): Observable<ResultOfUpdateAirportCommandDto> {
        let url_ = this.baseUrl + "/api/Airport/UpdateAirport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAirport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAirport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateAirportCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateAirportCommandDto>;
        }));
    }

    protected processUpdateAirport(response: HttpResponseBase): Observable<ResultOfUpdateAirportCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateAirportCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAuthClient {
    login(userName: string | null | undefined, password: string | null | undefined, isPersistent: boolean, lockOutOnFailure: boolean): Observable<ResultOfLoginDto>;
    logOut(userId: string | null | undefined): Observable<ResultOfLogoutDto>;
    geLoggedIn(): Observable<ResultOfGetLoggedInQueryDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(userName: string | null | undefined, password: string | null | undefined, isPersistent: boolean, lockOutOnFailure: boolean): Observable<ResultOfLoginDto> {
        let url_ = this.baseUrl + "/api/Auth/Login?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (isPersistent === undefined || isPersistent === null)
            throw new Error("The parameter 'isPersistent' must be defined and cannot be null.");
        else
            url_ += "IsPersistent=" + encodeURIComponent("" + isPersistent) + "&";
        if (lockOutOnFailure === undefined || lockOutOnFailure === null)
            throw new Error("The parameter 'lockOutOnFailure' must be defined and cannot be null.");
        else
            url_ += "LockOutOnFailure=" + encodeURIComponent("" + lockOutOnFailure) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfLoginDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfLoginDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResultOfLoginDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfLoginDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logOut(userId: string | null | undefined): Observable<ResultOfLogoutDto> {
        let url_ = this.baseUrl + "/api/Auth/LogOut?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfLogoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfLogoutDto>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<ResultOfLogoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfLogoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    geLoggedIn(): Observable<ResultOfGetLoggedInQueryDto> {
        let url_ = this.baseUrl + "/api/Auth/GeLoggedIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeLoggedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeLoggedIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetLoggedInQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetLoggedInQueryDto>;
        }));
    }

    protected processGeLoggedIn(response: HttpResponseBase): Observable<ResultOfGetLoggedInQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetLoggedInQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBookingsClient {
    getAllBookings(): Observable<GetAllBookingQueryDto[]>;
    getBookingById(uniqueId: string | null | undefined): Observable<ResultOfGetBookingByIdQueryDto>;
    getBookingByName(lastName: string | null | undefined): Observable<GetBookingByNameQueryDto[]>;
    createBooking(command: CreateBookingCommand): Observable<ResultOfCreateBookingCommandDto>;
    updateBooking(command: UpdateBookingCommand): Observable<ResultOfUpdateBookingCommandDto>;
}

@Injectable({
    providedIn: 'root'
})
export class BookingsClient implements IBookingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllBookings(): Observable<GetAllBookingQueryDto[]> {
        let url_ = this.baseUrl + "/api/Bookings/GetAllBookings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBookings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllBookingQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllBookingQueryDto[]>;
        }));
    }

    protected processGetAllBookings(response: HttpResponseBase): Observable<GetAllBookingQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllBookingQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBookingById(uniqueId: string | null | undefined): Observable<ResultOfGetBookingByIdQueryDto> {
        let url_ = this.baseUrl + "/api/Bookings/GetBookingById?";
        if (uniqueId !== undefined && uniqueId !== null)
            url_ += "UniqueId=" + encodeURIComponent("" + uniqueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetBookingByIdQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetBookingByIdQueryDto>;
        }));
    }

    protected processGetBookingById(response: HttpResponseBase): Observable<ResultOfGetBookingByIdQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetBookingByIdQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBookingByName(lastName: string | null | undefined): Observable<GetBookingByNameQueryDto[]> {
        let url_ = this.baseUrl + "/api/Bookings/GetBookingByName?";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookingByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookingByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBookingByNameQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBookingByNameQueryDto[]>;
        }));
    }

    protected processGetBookingByName(response: HttpResponseBase): Observable<GetBookingByNameQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetBookingByNameQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBooking(command: CreateBookingCommand): Observable<ResultOfCreateBookingCommandDto> {
        let url_ = this.baseUrl + "/api/Bookings/CreateBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateBookingCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateBookingCommandDto>;
        }));
    }

    protected processCreateBooking(response: HttpResponseBase): Observable<ResultOfCreateBookingCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateBookingCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBooking(command: UpdateBookingCommand): Observable<ResultOfUpdateBookingCommandDto> {
        let url_ = this.baseUrl + "/api/Bookings/UpdateBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateBookingCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateBookingCommandDto>;
        }));
    }

    protected processUpdateBooking(response: HttpResponseBase): Observable<ResultOfUpdateBookingCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateBookingCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountryClient {
    getCountry(): Observable<GetAllCountryQueryDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CountryClient implements ICountryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCountry(): Observable<GetAllCountryQueryDto[]> {
        let url_ = this.baseUrl + "/api/Country";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCountryQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCountryQueryDto[]>;
        }));
    }

    protected processGetCountry(response: HttpResponseBase): Observable<GetAllCountryQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllCountryQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFlightsClient {
    getAllFlights(): Observable<GetAllFlightQueryDto[]>;
    getFlightById(uniqueId: string | null | undefined): Observable<ResultOfGetFlightByIdQueryDto>;
    getFlightByName(flightCode: string | null | undefined): Observable<GetFlightNameQueryDto[]>;
    createFlight(command: CreateFlightCommand): Observable<ResultOfCreateFlightCommandDto>;
    updateFlight(command: UpdateFlightCommand): Observable<ResultOfUpdateFlightCommandDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FlightsClient implements IFlightsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllFlights(): Observable<GetAllFlightQueryDto[]> {
        let url_ = this.baseUrl + "/api/Flights/GetAllFlights";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFlights(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFlights(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllFlightQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllFlightQueryDto[]>;
        }));
    }

    protected processGetAllFlights(response: HttpResponseBase): Observable<GetAllFlightQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllFlightQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFlightById(uniqueId: string | null | undefined): Observable<ResultOfGetFlightByIdQueryDto> {
        let url_ = this.baseUrl + "/api/Flights/GetFlightById?";
        if (uniqueId !== undefined && uniqueId !== null)
            url_ += "UniqueId=" + encodeURIComponent("" + uniqueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFlightById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFlightById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetFlightByIdQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetFlightByIdQueryDto>;
        }));
    }

    protected processGetFlightById(response: HttpResponseBase): Observable<ResultOfGetFlightByIdQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetFlightByIdQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFlightByName(flightCode: string | null | undefined): Observable<GetFlightNameQueryDto[]> {
        let url_ = this.baseUrl + "/api/Flights/GetFlightByName?";
        if (flightCode !== undefined && flightCode !== null)
            url_ += "FlightCode=" + encodeURIComponent("" + flightCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFlightByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFlightByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFlightNameQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFlightNameQueryDto[]>;
        }));
    }

    protected processGetFlightByName(response: HttpResponseBase): Observable<GetFlightNameQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetFlightNameQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createFlight(command: CreateFlightCommand): Observable<ResultOfCreateFlightCommandDto> {
        let url_ = this.baseUrl + "/api/Flights/CreateFlight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFlight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFlight(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateFlightCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateFlightCommandDto>;
        }));
    }

    protected processCreateFlight(response: HttpResponseBase): Observable<ResultOfCreateFlightCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateFlightCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateFlight(command: UpdateFlightCommand): Observable<ResultOfUpdateFlightCommandDto> {
        let url_ = this.baseUrl + "/api/Flights/UpdateFlight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFlight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFlight(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateFlightCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateFlightCommandDto>;
        }));
    }

    protected processUpdateFlight(response: HttpResponseBase): Observable<ResultOfUpdateFlightCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateFlightCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPlanesClient {
    getAllPlanes(): Observable<GetAllPlanesQueryDto[]>;
    getPlaneById(uniqueId: string | null | undefined): Observable<ResultOfGetPlaneByIdQueryDto>;
    getPlaneByName(airlineName: string | null | undefined): Observable<GetPlaneByNameQueryDto[]>;
    createAirline(command: CreateAirlineCommand): Observable<ResultOfCreateAirlineCommandDto>;
    updateAirline(command: UpdateAirlineCommand): Observable<ResultOfUpdateAirlineCommandDto>;
}

@Injectable({
    providedIn: 'root'
})
export class PlanesClient implements IPlanesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllPlanes(): Observable<GetAllPlanesQueryDto[]> {
        let url_ = this.baseUrl + "/api/Planes/GetAllPlanes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPlanes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPlanes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPlanesQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPlanesQueryDto[]>;
        }));
    }

    protected processGetAllPlanes(response: HttpResponseBase): Observable<GetAllPlanesQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllPlanesQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPlaneById(uniqueId: string | null | undefined): Observable<ResultOfGetPlaneByIdQueryDto> {
        let url_ = this.baseUrl + "/api/Planes/GetPlaneById?";
        if (uniqueId !== undefined && uniqueId !== null)
            url_ += "UniqueId=" + encodeURIComponent("" + uniqueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlaneById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlaneById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetPlaneByIdQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetPlaneByIdQueryDto>;
        }));
    }

    protected processGetPlaneById(response: HttpResponseBase): Observable<ResultOfGetPlaneByIdQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetPlaneByIdQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPlaneByName(airlineName: string | null | undefined): Observable<GetPlaneByNameQueryDto[]> {
        let url_ = this.baseUrl + "/api/Planes/GetPlaneByName?";
        if (airlineName !== undefined && airlineName !== null)
            url_ += "AirlineName=" + encodeURIComponent("" + airlineName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlaneByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlaneByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPlaneByNameQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPlaneByNameQueryDto[]>;
        }));
    }

    protected processGetPlaneByName(response: HttpResponseBase): Observable<GetPlaneByNameQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPlaneByNameQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createAirline(command: CreateAirlineCommand): Observable<ResultOfCreateAirlineCommandDto> {
        let url_ = this.baseUrl + "/api/Planes/CreateAirline";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAirline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAirline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateAirlineCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateAirlineCommandDto>;
        }));
    }

    protected processCreateAirline(response: HttpResponseBase): Observable<ResultOfCreateAirlineCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateAirlineCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAirline(command: UpdateAirlineCommand): Observable<ResultOfUpdateAirlineCommandDto> {
        let url_ = this.baseUrl + "/api/Planes/UpdateAirline";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAirline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAirline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateAirlineCommandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateAirlineCommandDto>;
        }));
    }

    protected processUpdateAirline(response: HttpResponseBase): Observable<ResultOfUpdateAirlineCommandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateAirlineCommandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUsersClient {
    allUsersByName(searchValue: string | null | undefined, pageNumber: number, pageSize: number): Observable<ResultOfUsersListDto>;
    getUserByID(id: string | null | undefined): Observable<ResultOfUserByIDDto>;
    createIdentityUser(command: CreateUserCommand): Observable<ResultOfCreateUserDto>;
    updateIdentityUser(command: UpdateUserCommand): Observable<ResultOfUpdateUserDto>;
    updatePassword(command: UpdatePasswordCommand): Observable<ResultOfUpdatePasswordDto>;
    getPassword(): Observable<ResultOfGeneratePasswordDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    allUsersByName(searchValue: string | null | undefined, pageNumber: number, pageSize: number): Observable<ResultOfUsersListDto> {
        let url_ = this.baseUrl + "/api/Users/AllUsersByName?";
        if (searchValue !== undefined && searchValue !== null)
            url_ += "SearchValue=" + encodeURIComponent("" + searchValue) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllUsersByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllUsersByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUsersListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUsersListDto>;
        }));
    }

    protected processAllUsersByName(response: HttpResponseBase): Observable<ResultOfUsersListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUsersListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserByID(id: string | null | undefined): Observable<ResultOfUserByIDDto> {
        let url_ = this.baseUrl + "/api/Users/GetUserByID?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUserByIDDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUserByIDDto>;
        }));
    }

    protected processGetUserByID(response: HttpResponseBase): Observable<ResultOfUserByIDDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserByIDDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createIdentityUser(command: CreateUserCommand): Observable<ResultOfCreateUserDto> {
        let url_ = this.baseUrl + "/api/Users/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateUserDto>;
        }));
    }

    protected processCreateIdentityUser(response: HttpResponseBase): Observable<ResultOfCreateUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateIdentityUser(command: UpdateUserCommand): Observable<ResultOfUpdateUserDto> {
        let url_ = this.baseUrl + "/api/Users/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateUserDto>;
        }));
    }

    protected processUpdateIdentityUser(response: HttpResponseBase): Observable<ResultOfUpdateUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePassword(command: UpdatePasswordCommand): Observable<ResultOfUpdatePasswordDto> {
        let url_ = this.baseUrl + "/api/Users/UpdatePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdatePasswordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdatePasswordDto>;
        }));
    }

    protected processUpdatePassword(response: HttpResponseBase): Observable<ResultOfUpdatePasswordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdatePasswordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPassword(): Observable<ResultOfGeneratePasswordDto> {
        let url_ = this.baseUrl + "/api/Users/GenerateRandomPassword";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGeneratePasswordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGeneratePasswordDto>;
        }));
    }

    protected processGetPassword(response: HttpResponseBase): Observable<ResultOfGeneratePasswordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGeneratePasswordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GetAllAirportByCountryQueryDto implements IGetAllAirportByCountryQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;

    constructor(data?: IGetAllAirportByCountryQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.uniqueId = _data["uniqueId"];
            this.airportName = _data["airportName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): GetAllAirportByCountryQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAirportByCountryQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniqueId"] = this.uniqueId;
        data["airportName"] = this.airportName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IGetAllAirportByCountryQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
}

export class ResultOfGetAirportByIdQueryDto implements IResultOfGetAirportByIdQueryDto {
    data?: GetAirportByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGetAirportByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetAirportByIdQueryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGetAirportByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetAirportByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGetAirportByIdQueryDto {
    data?: GetAirportByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GetAirportByIdQueryDto implements IGetAirportByIdQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetAirportByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.uniqueId = _data["uniqueId"];
            this.airportName = _data["airportName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetAirportByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAirportByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniqueId"] = this.uniqueId;
        data["airportName"] = this.airportName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetAirportByIdQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    isActive?: boolean | undefined;
}

export enum ResultType {
    Success = 1,
    Warning = 2,
    Error = 3,
    Information = 4,
}

export class GetAllAirportQueryDto implements IGetAllAirportQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetAllAirportQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.uniqueId = _data["uniqueId"];
            this.airportName = _data["airportName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetAllAirportQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAirportQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniqueId"] = this.uniqueId;
        data["airportName"] = this.airportName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetAllAirportQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean | undefined;
}

export class GetAirportByNameQueryDto implements IGetAirportByNameQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetAirportByNameQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.uniqueId = _data["uniqueId"];
            this.airportName = _data["airportName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetAirportByNameQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAirportByNameQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniqueId"] = this.uniqueId;
        data["airportName"] = this.airportName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetAirportByNameQueryDto {
    id?: number | undefined;
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfCreateAirportCommandDto implements IResultOfCreateAirportCommandDto {
    data?: CreateAirportCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateAirportCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateAirportCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateAirportCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateAirportCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateAirportCommandDto {
    data?: CreateAirportCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateAirportCommandDto implements ICreateAirportCommandDto {
    id?: string | undefined;
    createdDate?: Date;

    constructor(data?: ICreateAirportCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateAirportCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAirportCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateAirportCommandDto {
    id?: string | undefined;
    createdDate?: Date;
}

export class CreateAirportCommand implements ICreateAirportCommand {
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: ICreateAirportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airportName = _data["airportName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateAirportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAirportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airportName"] = this.airportName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateAirportCommand {
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfUpdateAirportCommandDto implements IResultOfUpdateAirportCommandDto {
    data?: UpdateAirportCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateAirportCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateAirportCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateAirportCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateAirportCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateAirportCommandDto {
    data?: UpdateAirportCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateAirportCommandDto implements IUpdateAirportCommandDto {
    id?: string | undefined;
    updatedDate?: Date;

    constructor(data?: IUpdateAirportCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAirportCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAirportCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateAirportCommandDto {
    id?: string | undefined;
    updatedDate?: Date;
}

export class UpdateAirportCommand implements IUpdateAirportCommand {
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateAirportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueId = _data["uniqueId"];
            this.airportName = _data["airportName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAirportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAirportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueId"] = this.uniqueId;
        data["airportName"] = this.airportName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateAirportCommand {
    uniqueId?: string | undefined;
    airportName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    countryId?: number | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfLoginDto implements IResultOfLoginDto {
    data?: LoginDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfLoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LoginDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfLoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfLoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfLoginDto {
    data?: LoginDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class LoginDto implements ILoginDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ILoginDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfLogoutDto implements IResultOfLogoutDto {
    data?: LogoutDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfLogoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LogoutDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfLogoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfLogoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfLogoutDto {
    data?: LogoutDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class LogoutDto implements ILogoutDto {
    userId?: string | undefined;
    time?: Date | undefined;

    constructor(data?: ILogoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LogoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILogoutDto {
    userId?: string | undefined;
    time?: Date | undefined;
}

export class ResultOfGetLoggedInQueryDto implements IResultOfGetLoggedInQueryDto {
    data?: GetLoggedInQueryDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGetLoggedInQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetLoggedInQueryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGetLoggedInQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetLoggedInQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGetLoggedInQueryDto {
    data?: GetLoggedInQueryDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GetLoggedInQueryDto implements IGetLoggedInQueryDto {
    loggedInId?: string | undefined;

    constructor(data?: IGetLoggedInQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loggedInId = _data["loggedInId"];
        }
    }

    static fromJS(data: any): GetLoggedInQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLoggedInQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loggedInId"] = this.loggedInId;
        return data;
    }
}

export interface IGetLoggedInQueryDto {
    loggedInId?: string | undefined;
}

export class GetAllBookingQueryDto implements IGetAllBookingQueryDto {
    id?: number | undefined;
    flightId?: number | undefined;
    flightCode?: string | undefined;
    flightDate?: string | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
    uniqueId?: string | undefined;
    avatarColor?: string | undefined;

    constructor(data?: IGetAllBookingQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightId = _data["flightId"];
            this.flightCode = _data["flightCode"];
            this.flightDate = _data["flightDate"];
            this.airportName = _data["airportName"];
            this.planeName = _data["planeName"];
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.avatar = _data["avatar"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
            this.uniqueId = _data["uniqueId"];
            this.avatarColor = _data["avatarColor"];
        }
    }

    static fromJS(data: any): GetAllBookingQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBookingQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightId"] = this.flightId;
        data["flightCode"] = this.flightCode;
        data["flightDate"] = this.flightDate;
        data["airportName"] = this.airportName;
        data["planeName"] = this.planeName;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["avatar"] = this.avatar;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        data["uniqueId"] = this.uniqueId;
        data["avatarColor"] = this.avatarColor;
        return data;
    }
}

export interface IGetAllBookingQueryDto {
    id?: number | undefined;
    flightId?: number | undefined;
    flightCode?: string | undefined;
    flightDate?: string | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
    uniqueId?: string | undefined;
    avatarColor?: string | undefined;
}

export class ResultOfGetBookingByIdQueryDto implements IResultOfGetBookingByIdQueryDto {
    data?: GetBookingByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGetBookingByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetBookingByIdQueryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGetBookingByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetBookingByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGetBookingByIdQueryDto {
    data?: GetBookingByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GetBookingByIdQueryDto implements IGetBookingByIdQueryDto {
    id?: number | undefined;
    flightId?: number | undefined;
    flightDate?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
    uniqueId?: string | undefined;
    avatarColor?: string | undefined;

    constructor(data?: IGetBookingByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightId = _data["flightId"];
            this.flightDate = _data["flightDate"];
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.avatar = _data["avatar"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
            this.uniqueId = _data["uniqueId"];
            this.avatarColor = _data["avatarColor"];
        }
    }

    static fromJS(data: any): GetBookingByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookingByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightId"] = this.flightId;
        data["flightDate"] = this.flightDate;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["avatar"] = this.avatar;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        data["uniqueId"] = this.uniqueId;
        data["avatarColor"] = this.avatarColor;
        return data;
    }
}

export interface IGetBookingByIdQueryDto {
    id?: number | undefined;
    flightId?: number | undefined;
    flightDate?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
    uniqueId?: string | undefined;
    avatarColor?: string | undefined;
}

export class GetBookingByNameQueryDto implements IGetBookingByNameQueryDto {
    id?: number | undefined;
    flightId?: number | undefined;
    flightCode?: string | undefined;
    flightDate?: string | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
    uniqueId?: string | undefined;
    avatarColor?: string | undefined;

    constructor(data?: IGetBookingByNameQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightId = _data["flightId"];
            this.flightCode = _data["flightCode"];
            this.flightDate = _data["flightDate"];
            this.airportName = _data["airportName"];
            this.planeName = _data["planeName"];
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.avatar = _data["avatar"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
            this.uniqueId = _data["uniqueId"];
            this.avatarColor = _data["avatarColor"];
        }
    }

    static fromJS(data: any): GetBookingByNameQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookingByNameQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightId"] = this.flightId;
        data["flightCode"] = this.flightCode;
        data["flightDate"] = this.flightDate;
        data["airportName"] = this.airportName;
        data["planeName"] = this.planeName;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["avatar"] = this.avatar;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        data["uniqueId"] = this.uniqueId;
        data["avatarColor"] = this.avatarColor;
        return data;
    }
}

export interface IGetBookingByNameQueryDto {
    id?: number | undefined;
    flightId?: number | undefined;
    flightCode?: string | undefined;
    flightDate?: string | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
    uniqueId?: string | undefined;
    avatarColor?: string | undefined;
}

export class ResultOfCreateBookingCommandDto implements IResultOfCreateBookingCommandDto {
    data?: CreateBookingCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateBookingCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateBookingCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateBookingCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateBookingCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateBookingCommandDto {
    data?: CreateBookingCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateBookingCommandDto implements ICreateBookingCommandDto {
    id?: string | undefined;
    createdDate?: Date;

    constructor(data?: ICreateBookingCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateBookingCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookingCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateBookingCommandDto {
    id?: string | undefined;
    createdDate?: Date;
}

export class CreateBookingCommand implements ICreateBookingCommand {
    flightId?: number | undefined;
    flightDate?: Date | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ICreateBookingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flightId = _data["flightId"];
            this.flightDate = _data["flightDate"] ? new Date(_data["flightDate"].toString()) : <any>undefined;
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): CreateBookingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flightId"] = this.flightId;
        data["flightDate"] = this.flightDate ? this.flightDate.toISOString() : <any>undefined;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ICreateBookingCommand {
    flightId?: number | undefined;
    flightDate?: Date | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUpdateBookingCommandDto implements IResultOfUpdateBookingCommandDto {
    data?: UpdateBookingCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateBookingCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateBookingCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateBookingCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateBookingCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateBookingCommandDto {
    data?: UpdateBookingCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateBookingCommandDto implements IUpdateBookingCommandDto {
    id?: string | undefined;
    updatedDate?: Date;

    constructor(data?: IUpdateBookingCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateBookingCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookingCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateBookingCommandDto {
    id?: string | undefined;
    updatedDate?: Date;
}

export class UpdateBookingCommand implements IUpdateBookingCommand {
    uniqueId?: string | undefined;
    flightId?: number | undefined;
    flightDate?: Date | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUpdateBookingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueId = _data["uniqueId"];
            this.flightId = _data["flightId"];
            this.flightDate = _data["flightDate"] ? new Date(_data["flightDate"].toString()) : <any>undefined;
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.middleName = _data["middleName"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UpdateBookingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueId"] = this.uniqueId;
        data["flightId"] = this.flightId;
        data["flightDate"] = this.flightDate ? this.flightDate.toISOString() : <any>undefined;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUpdateBookingCommand {
    uniqueId?: string | undefined;
    flightId?: number | undefined;
    flightDate?: Date | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    middleName?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class GetAllCountryQueryDto implements IGetAllCountryQueryDto {
    id?: number | undefined;
    countryName?: string | undefined;
    countryCode?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGetAllCountryQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryName = _data["countryName"];
            this.countryCode = _data["countryCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllCountryQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCountryQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryName"] = this.countryName;
        data["countryCode"] = this.countryCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetAllCountryQueryDto {
    id?: number | undefined;
    countryName?: string | undefined;
    countryCode?: string | undefined;
    description?: string | undefined;
}

export class GetAllFlightQueryDto implements IGetAllFlightQueryDto {
    id?: number | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetAllFlightQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightCode = _data["flightCode"];
            this.airportId = _data["airportId"];
            this.planeId = _data["planeId"];
            this.airportName = _data["airportName"];
            this.planeName = _data["planeName"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetAllFlightQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllFlightQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightCode"] = this.flightCode;
        data["airportId"] = this.airportId;
        data["planeId"] = this.planeId;
        data["airportName"] = this.airportName;
        data["planeName"] = this.planeName;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetAllFlightQueryDto {
    id?: number | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfGetFlightByIdQueryDto implements IResultOfGetFlightByIdQueryDto {
    data?: GetFlightByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGetFlightByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetFlightByIdQueryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGetFlightByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetFlightByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGetFlightByIdQueryDto {
    data?: GetFlightByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GetFlightByIdQueryDto implements IGetFlightByIdQueryDto {
    id?: number | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetFlightByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightCode = _data["flightCode"];
            this.airportId = _data["airportId"];
            this.planeId = _data["planeId"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetFlightByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFlightByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightCode"] = this.flightCode;
        data["airportId"] = this.airportId;
        data["planeId"] = this.planeId;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetFlightByIdQueryDto {
    id?: number | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class GetFlightNameQueryDto implements IGetFlightNameQueryDto {
    id?: number | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetFlightNameQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightCode = _data["flightCode"];
            this.airportId = _data["airportId"];
            this.planeId = _data["planeId"];
            this.airportName = _data["airportName"];
            this.planeName = _data["planeName"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetFlightNameQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFlightNameQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightCode"] = this.flightCode;
        data["airportId"] = this.airportId;
        data["planeId"] = this.planeId;
        data["airportName"] = this.airportName;
        data["planeName"] = this.planeName;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetFlightNameQueryDto {
    id?: number | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    airportName?: string | undefined;
    planeName?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfCreateFlightCommandDto implements IResultOfCreateFlightCommandDto {
    data?: CreateFlightCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateFlightCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateFlightCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateFlightCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateFlightCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateFlightCommandDto {
    data?: CreateFlightCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateFlightCommandDto implements ICreateFlightCommandDto {
    id?: string | undefined;
    createdDate?: Date;

    constructor(data?: ICreateFlightCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateFlightCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFlightCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateFlightCommandDto {
    id?: string | undefined;
    createdDate?: Date;
}

export class CreateFlightCommand implements ICreateFlightCommand {
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;

    constructor(data?: ICreateFlightCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flightCode = _data["flightCode"];
            this.airportId = _data["airportId"];
            this.planeId = _data["planeId"];
        }
    }

    static fromJS(data: any): CreateFlightCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFlightCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flightCode"] = this.flightCode;
        data["airportId"] = this.airportId;
        data["planeId"] = this.planeId;
        return data;
    }
}

export interface ICreateFlightCommand {
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
}

export class ResultOfUpdateFlightCommandDto implements IResultOfUpdateFlightCommandDto {
    data?: UpdateFlightCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateFlightCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateFlightCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateFlightCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateFlightCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateFlightCommandDto {
    data?: UpdateFlightCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateFlightCommandDto implements IUpdateFlightCommandDto {
    id?: string | undefined;
    updatedDate?: Date;

    constructor(data?: IUpdateFlightCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateFlightCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFlightCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateFlightCommandDto {
    id?: string | undefined;
    updatedDate?: Date;
}

export class UpdateFlightCommand implements IUpdateFlightCommand {
    uniqueId?: string | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateFlightCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueId = _data["uniqueId"];
            this.flightCode = _data["flightCode"];
            this.airportId = _data["airportId"];
            this.planeId = _data["planeId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateFlightCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFlightCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueId"] = this.uniqueId;
        data["flightCode"] = this.flightCode;
        data["airportId"] = this.airportId;
        data["planeId"] = this.planeId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateFlightCommand {
    uniqueId?: string | undefined;
    flightCode?: string | undefined;
    airportId?: number | undefined;
    planeId?: number | undefined;
    isActive?: boolean | undefined;
}

export class GetAllPlanesQueryDto implements IGetAllPlanesQueryDto {
    id?: number | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetAllPlanesQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.airlineName = _data["airlineName"];
            this.code = _data["code"];
            this.model = _data["model"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetAllPlanesQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPlanesQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["airlineName"] = this.airlineName;
        data["code"] = this.code;
        data["model"] = this.model;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetAllPlanesQueryDto {
    id?: number | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfGetPlaneByIdQueryDto implements IResultOfGetPlaneByIdQueryDto {
    data?: GetPlaneByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGetPlaneByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetPlaneByIdQueryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGetPlaneByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetPlaneByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGetPlaneByIdQueryDto {
    data?: GetPlaneByIdQueryDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GetPlaneByIdQueryDto implements IGetPlaneByIdQueryDto {
    id?: number | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetPlaneByIdQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.airlineName = _data["airlineName"];
            this.code = _data["code"];
            this.model = _data["model"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetPlaneByIdQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlaneByIdQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["airlineName"] = this.airlineName;
        data["code"] = this.code;
        data["model"] = this.model;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetPlaneByIdQueryDto {
    id?: number | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class GetPlaneByNameQueryDto implements IGetPlaneByNameQueryDto {
    id?: number | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IGetPlaneByNameQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.airlineName = _data["airlineName"];
            this.code = _data["code"];
            this.model = _data["model"];
            this.uniqueId = _data["uniqueId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetPlaneByNameQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlaneByNameQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["airlineName"] = this.airlineName;
        data["code"] = this.code;
        data["model"] = this.model;
        data["uniqueId"] = this.uniqueId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetPlaneByNameQueryDto {
    id?: number | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    uniqueId?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfCreateAirlineCommandDto implements IResultOfCreateAirlineCommandDto {
    data?: CreateAirlineCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateAirlineCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateAirlineCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateAirlineCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateAirlineCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateAirlineCommandDto {
    data?: CreateAirlineCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateAirlineCommandDto implements ICreateAirlineCommandDto {
    id?: string | undefined;
    createdDate?: Date;

    constructor(data?: ICreateAirlineCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateAirlineCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAirlineCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateAirlineCommandDto {
    id?: string | undefined;
    createdDate?: Date;
}

export class CreateAirlineCommand implements ICreateAirlineCommand {
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;

    constructor(data?: ICreateAirlineCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airlineName = _data["airlineName"];
            this.code = _data["code"];
            this.model = _data["model"];
        }
    }

    static fromJS(data: any): CreateAirlineCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAirlineCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airlineName"] = this.airlineName;
        data["code"] = this.code;
        data["model"] = this.model;
        return data;
    }
}

export interface ICreateAirlineCommand {
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
}

export class ResultOfUpdateAirlineCommandDto implements IResultOfUpdateAirlineCommandDto {
    data?: UpdateAirlineCommandDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateAirlineCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateAirlineCommandDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateAirlineCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateAirlineCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateAirlineCommandDto {
    data?: UpdateAirlineCommandDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateAirlineCommandDto implements IUpdateAirlineCommandDto {
    id?: string | undefined;
    updatedDate?: Date;

    constructor(data?: IUpdateAirlineCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAirlineCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAirlineCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateAirlineCommandDto {
    id?: string | undefined;
    updatedDate?: Date;
}

export class UpdateAirlineCommand implements IUpdateAirlineCommand {
    uniqueId?: string | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateAirlineCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueId = _data["uniqueId"];
            this.airlineName = _data["airlineName"];
            this.code = _data["code"];
            this.model = _data["model"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAirlineCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAirlineCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueId"] = this.uniqueId;
        data["airlineName"] = this.airlineName;
        data["code"] = this.code;
        data["model"] = this.model;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateAirlineCommand {
    uniqueId?: string | undefined;
    airlineName?: string | undefined;
    code?: string | undefined;
    model?: string | undefined;
    isActive?: boolean | undefined;
}

export class ResultOfUsersListDto implements IResultOfUsersListDto {
    data?: UsersListDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UsersListDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUsersListDto {
    data?: UsersListDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UsersListDto implements IUsersListDto {
    users?: UsersDto[] | undefined;

    constructor(data?: IUsersListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UsersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUsersListDto {
    users?: UsersDto[] | undefined;
}

export class UsersDto implements IUsersDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUsersDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUserByIDDto implements IResultOfUserByIDDto {
    data?: UserByIDDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUserByIDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserByIDDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUserByIDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUserByIDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUserByIDDto {
    data?: UserByIDDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UserByIDDto implements IUserByIDDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUserByIDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UserByIDDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserByIDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUserByIDDto {
    id?: string | undefined;
    avatar?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfCreateUserDto implements IResultOfCreateUserDto {
    data?: CreateUserDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfCreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateUserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfCreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfCreateUserDto {
    data?: CreateUserDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class CreateUserDto implements ICreateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.isAdminAccount = _data["isAdminAccount"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["isAdminAccount"] = this.isAdminAccount;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ICreateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    isAdminAccount?: boolean | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    userName?: string | undefined;
    password?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface ICreateUserCommand {
    userName?: string | undefined;
    password?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUpdateUserDto implements IResultOfUpdateUserDto {
    data?: UpdateUserDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateUserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdateUserDto {
    data?: UpdateUserDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdateUserDto implements IUpdateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUpdateUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.emailAddress = _data["emailAddress"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.region = _data["region"];
            this.zipCode = _data["zipCode"];
            this.contactNumber = _data["contactNumber"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["emailAddress"] = this.emailAddress;
        data["street"] = this.street;
        data["city"] = this.city;
        data["province"] = this.province;
        data["region"] = this.region;
        data["zipCode"] = this.zipCode;
        data["contactNumber"] = this.contactNumber;
        return data;
    }
}

export interface IUpdateUserCommand {
    id?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    emailAddress?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    region?: string | undefined;
    zipCode?: string | undefined;
    contactNumber?: string | undefined;
}

export class ResultOfUpdatePasswordDto implements IResultOfUpdatePasswordDto {
    data?: UpdatePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfUpdatePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdatePasswordDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfUpdatePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdatePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfUpdatePasswordDto {
    data?: UpdatePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class UpdatePasswordDto implements IUpdatePasswordDto {
    id?: string | undefined;
    updatedDate?: Date | undefined;

    constructor(data?: IUpdatePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdatePasswordDto {
    id?: string | undefined;
    updatedDate?: Date | undefined;
}

export class UpdatePasswordCommand implements IUpdatePasswordCommand {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IUpdatePasswordCommand {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class ResultOfGeneratePasswordDto implements IResultOfGeneratePasswordDto {
    data?: GeneratePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;

    constructor(data?: IResultOfGeneratePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GeneratePasswordDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.resultType = _data["resultType"];
        }
    }

    static fromJS(data: any): ResultOfGeneratePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGeneratePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["resultType"] = this.resultType;
        return data;
    }
}

export interface IResultOfGeneratePasswordDto {
    data?: GeneratePasswordDto | undefined;
    message?: string;
    resultType?: ResultType;
}

export class GeneratePasswordDto implements IGeneratePasswordDto {
    password?: string | undefined;

    constructor(data?: IGeneratePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GeneratePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }
}

export interface IGeneratePasswordDto {
    password?: string | undefined;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}